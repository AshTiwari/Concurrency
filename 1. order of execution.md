# Order of Execution

**Intro** - How tasks are organized and executed in time.<br>
**Not language-specific** - This is a fundamental concept that exists at the OS/hardware level.

**Order of Execution:**
  - Sequential
  - Concurrent
    - Single Cores
    - Multi Cores
        - CPU Intensive Process
        - I/O Bound Process


## Sequential:
Sequential means tasks execute one after another, in order. Task B starts only after Task A completes.


## Concurrent:
- Concurrent means tasks are **in progress** at the **same time** but not necessarily **running** at the **same time**
- **Key insight:** Concurrency is about structure (how you organize tasks), not necessarily about parallelism (running truly simultaneously)
- The OS can **interleave** these tasks - switching between them rapidly
- The OS scheduler manages multiple **execution contexts** (threads/goroutines/async tasks)
- This is called **time-slicing** or **context switching**


## Context Switch in a **Single Core System** vs a **Multi Core System** in a Concurrent System:

### Single Core:
- Even on a single CPU core, the OS switches between tasks so fast it **appears** they're running "at the same time"

### Multiple cores:

In a multi core system, the scheduler assigns tasks to cores dynamically. 

#### when Cores < Tasks:
- e.g. 3 tasks and 4 cores
- The scheduler divides total CPU capacity equally among ready tasks. The **preiodic timer** interrupts a task and makes it yield (leave) the core so that the next task can get the core.
- **Illusion of concurrency** —each task makes steady (if slower) progress. 
- Total throughput is high, but per-task speed is less than that of what it'd be on a dedicated core (due to sharing + switch overhead)

#### when Cores > Tasks
- e.g. 3 cores and 4 tasks
- Context switching is Minimal and rarely on the same core
- Switches are opportunistic, not mandatory for progress.
- However, if a task blocks (e.g., brief I/O wait), its core becomes available, and the scheduler might migrate another task to it for better distribution.
- OS might "pin" tasks to cores to minimize switches (e.g., via `taskset` in Linux).
- The OS scheduler *could* switch tasks across cores, even with 3 tasks on 4 cores but it is highly unlikely as it is inefficient and modern schedulers will not do it.
- Schedulers are smart enough to favor stability for efficiency. This keeps your "progress at the same time" intact with vanishingly small overhead.

**Advance topics to study in this:**
- Enable Pinning: We can use tools to bind tasks—eliminates migration entirely. Like 
    - `numactl` in Linux
    - APIs in code e.g., `pthread_setaffinity_np` in C++


## How different **Processes** affect execution speed in a **Single Core System** vs a **Multi Core System**:

Consider a program which has 4 tasks and each tasks take on an average 3 units of time.

- Sequential: Single core or multi-core doesn't affect the speed of execution of the code. In the above scenario, the program will take 3 * 4 = 12 unit of time to finish in both single & multi core system.



- Concurrent:
  - Single Core System:
    - 4 CPU intensive tasks:
      - A single core **rapidly** switches between the 4 tasks. 
      - Each task will still take 3 unit of time.
      - So the total time spent on all 4 tasks is 3*4=12 units of time
      - However, some additional time is spent in switching between the tasks.
  
    - 4 I/O Bound tasks:
      - A single core **rapidly** switches between the 4 tasks. 
      - Each I/O bound task will take only 3 unit of time since it is trigerred.
      - After a process is trigerred, it will wait for the I/O to finish irrespective of if a core is assigned to it or not (due to the nature of an I/O process)

  - Multi Core System:
    - 4 CPU intensive tasks (assuming 4 cores available):
      - Each task gets assigned to a separate core.
      - All 4 tasks run **truly in parallel** (not just concurrently).
      - Each task still takes 3 units of time to complete.
      - **Total program completion time: 3 units** (since all tasks finish simultaneously).
      - No context switching overhead between tasks.
      - This is **true parallelism** - tasks are actually running at the same time.

    - 4 I/O Bound tasks (assuming 4 cores available):
      - Each task gets assigned to a separate core initially.
      - Each task triggers its I/O operation (takes 1 unit of CPU time).
      - After triggering I/O, the core becomes idle while waiting for I/O completion.
      - I/O operations complete independently (takes 2 additional units of time).
      - **Total program completion time: 3 units** (1 unit CPU + 2 units I/O wait).
      - Cores are underutilized - they sit idle during I/O wait periods.

**Note:** For the sake of illustration, below Gantt chart shows that a Multi-Core I/O Bound system is faster than a Sinlge-Core I/O Bound system but in reality it takes a very small amount of time to trigger a I/O bound process and it takes a large amount of time to finish the I/O work so the time difference between a Single-Core system and a Multi-Core system is not very much and does not justify the underutilization of 4 cores. 


#### Gantt-Style Timeline Table (Sequential Process)

| Task                          | Time 1 | Time 2 | Time 3 | Time 4 | Time 5 | Time 6 | Time 7 | Time 8 | Time 9 | Time 10 | Time 11 | Time 12 | Status at End                  |
|-------------------------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|---------|---------|---------|--------------------------------|
| **A**                         | [-A-]  | [-A-]  | [-A-]  | [done] | [done] | [done] | [done] | [done] | [done] | [done]  | [done]  | [done]  | Finished (after 3 units)      |
| **B**                         | [wait] | [wait] | [wait] | [-B-]  | [-B-]  | [-B-]  | [done] | [done] | [done] | [done]  | [done]  | [done]  | Finished (after 6 units)      |
| **C**                         | [wait] | [wait] | [wait] | [wait] | [wait] | [wait] | [-C-]  | [-C-]  | [-C-]  | [done]  | [done]  | [done]  | Finished (after 9 units)      |
| **D**                         | [wait] | [wait] | [wait] | [wait] | [wait] | [wait] | [wait] | [wait] | [wait] | [-D-]   | [-D-]   | [-D-]   | Finished (after 12 units)     |
| **Core**                      | [-A-]  | [-A-]  | [-A-]  | [-B-]  | [-B-]  | [-B-]  | [-C-]  | [-C-]  | [-C-]  | [-D-]   | [-D-]   | [-D-]   | Idle                           |

#### Gantt-Style Timeline Table (Concurrent Single-Core, 3 CPU-Bound Processes)

| Task                          | Time 1 | Time 2 | Time 3 | Time 4 | Time 5 | Time 6 | Time 7 | Time 8 | Time 9 | Status at End                  |
|-------------------------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------------------------------|
| **A**                         | [-A-]  | [wait] | [wait] | [-A-]  | [wait] | [wait] | [-A-]  | [done] | [done] | Finished (after 7 units)      |
| **B**                         | [wait] | [-B-]  | [wait] | [wait] | [-B-]  | [wait] | [wait] | [-B-]  | [done] | Finished (after 8 units)      |
| **C**                         | [wait] | [wait] | [-C-]  | [wait] | [wait] | [-C-]  | [wait] | [wait] | [-C-]  | Finished (after 9 units)      |
| **Core**                      | [-A-]  | [-B-]  | [-C-]  | [-A-]  | [-B-]  | [-C-]  | [-A-]  | [-B-]  | [-C-]  | Idle                           |


#### Gantt-Style Timeline Table (I/O-Bound Processes)

| Task                          | Time 1 | Time 2 | Time 3 | Time 4 | Time 5 | Time 6 | Time 7 | Status at End                  |
|-------------------------------|--------|--------|--------|--------|--------|--------|--------|--------------------------------|
| **A**                         | [-A-]  | [I/O]  | [I/O]  | [done] | [done] | [done] | [done] | Finished (after 4 units)      |
| **B**                         | [wait] | [-B-]  | [I/O]  | [I/O]  | [done] | [done] | [done] | Finished (after 5 units)      |
| **C**                         | [wait] | [wait] | [-C-]  | [I/O]  | [I/O]  | [done] | [done] | Finished (after 6 units)      |
| **D**                         | [wait] | [wait] | [wait] | [-D-]  | [I/O]  | [I/O]  | [done] | Finished (after 7 units)      |
| **Core**                      | [-A-]  | [-B-]  | [-C-]  | [-D-]  | [idle] | [idle] | [idle] | Idle                          |

#### Gantt-Style Timeline Table (4-Core, 4 CPU-Bound Tasks)

| Task/Core                      | Time 1 | Time 2 | Time 3 | Status at End                  |
|--------------------------------|--------|--------|--------|--------------------------------|
| **Task A (on Core 1)**         | [-A-]  | [-A-]  | [-A-]  | Finished (after 3 units)      |
| **Task B (on Core 2)**         | [-B-]  | [-B-]  | [-B-]  | Finished (after 3 units)      |
| **Task C (on Core 3)**         | [-C-]  | [-C-]  | [-C-]  | Finished (after 3 units)      |
| **Task D (on Core 4)**         | [-D-]  | [-D-]  | [-D-]  | Finished (after 3 units)      |
| **Core 1**                     | [-A-]  | [-A-]  | [-A-]  | Idle                           |
| **Core 2**                     | [-B-]  | [-B-]  | [-B-]  | Idle                           |
| **Core 3**                     | [-C-]  | [-C-]  | [-C-]  | Idle                           |
| **Core 4**                     | [-D-]  | [-D-]  | [-D-]  | Idle                           |


#### Gantt-Style Timeline Table (Parallel 4-Core, 4 I/O-Bound Tasks)

| Task/Core                      | Time 1 | Time 2 | Time 3 | Status at End                  |
|--------------------------------|--------|--------|--------|--------------------------------|
| **Task A (on Core 1)**         | [-A-]  | [I/O]  | [done] | Finished (after 3 units)      |
| **Task B (on Core 2)**         | [-B-]  | [I/O]  | [done] | Finished (after 3 units)      |
| **Task C (on Core 3)**         | [-C-]  | [I/O]  | [done] | Finished (after 3 units)      |
| **Task D (on Core 4)**         | [-D-]  | [I/O]  | [done] | Finished (after 3 units)      |
| **Core 1**                     | [-A-]  | [idle] | [idle] | Idle                           |
| **Core 2**                     | [-B-]  | [idle] | [idle] | Idle                           |
| **Core 3**                     | [-C-]  | [idle] | [idle] | Idle                           |
| **Core 4**                     | [-D-]  | [idle] | [idle] | Idle                           |

Inferences:
- A sequential process will be (marginally) faster than a concurrent single-core system for a CPU intensive task.
- A sequential process will be significantly slower than a concurrent multi-core system for a CPU intensive task.
- A sequential process will be significantly slower than a concurrent single-core system for a I/O bound task.
- A concurrent single-core system will be (marginally) slower than the concurrent multi-core system but doesn't underutilize cores so it is more desired.